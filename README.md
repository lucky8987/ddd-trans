#### DDD 领域驱动设计实践

**前言**

> DDD由来已久，背景知识应该不用多做介绍了，乘着微服务的东风，再一次席卷而来，关于DDD的讨论与看法至今没有一套完整的标准实现，因为DDD本身是一中架构思想，不是应用框架，所以认知不同可能导致实际落地造成偏差，正所谓`一千人就眼里有一千个哈姆莱特`，本着对DDD的好奇，尝试实践一个DDD项目，欢迎大家交流学习。



**工程结构：**

- **ddd-trans**  --  父工程：maven依赖、子模块聚合，纯POM
    - trans-api  						--- 接口层：对外暴露的接口以及DTO对象
    - trans-application            --- 应用层：服务启动、参数校验、领域模型对象构建
    - trans-domain                  --- 领域层：核心业务逻辑处理
    - trans-infrastructure       --- 基础设施：持久化、外部接口、中间件服务
    - trans-types                      --- 类型：构成Entity对象的基础类型，可暴露对外

**模块依赖：**

​		![image-20220106165352023](C:\Users\60007879\AppData\Roaming\Typora\typora-user-images\image-20220106165352023.png)

**模型规范：**

- **DTO（传输对象）：** Application层使用，用于接口层外部请求参数与响应数据的封装，DTO的价值在于适配不同的业务场景的入参和出参，避免让业务对象变成一个万能大对象。

- **Entity（实体对象）：** Domian层使用，实体对象是我们正常业务应该用的业务模型，它的字段和方法应该和业务语言保持一致，它的生命周期应该仅存在于内存中，不需要可序列化和可持久化。
- **DO（数据对象）：**DO应该仅仅作为数据库物理表格的映射，不能参与到业务逻辑中。为了简单明了，DO的字段类型和名称应该和数据库物理表格的字段类型和名称一一对应，DO仅作用于持久层Mapper中做数据映射。

|                    | DTO                  | Entity               | DO                               |
| ------------------ | -------------------- | -------------------- | -------------------------------- |
| **目的**           | 适配业务场景         | 业务逻辑             | 数据库表映射                     |
| **代码层级**       | 接口层（xxx-api）    | 领域层（xxx-domain） | 基础设施层（xxx-infrastructure） |
| **命名规范**       | XxxDTO、XxxRequest等 | Xxx                  | XxxDO                            |
| **字段名称标准**   | 接口定义时拟定       | 业务语言             | 数据库表字段名                   |
| **是否需要序列化** | 需要                 | 不需要               | 需要                             |
| **转换**           | 可以与Entity互转     | 可以与DTO、D0互转    | 可以与Entity互转                 |

**业务流程：**

![image-20220106180604837](C:\Users\60007879\AppData\Roaming\Typora\typora-user-images\image-20220106180604837.png)

以交易系统中的转账为示例，大致业务流程如上图所示：客户发起请求、应用层做基础的请求参数校验、获取收付款信息，进一步检查交易双方状态、权限、余额等信息、构建交易订单（先落库）、发起渠道下单、更新交易订单状态等信息。

**类图关系阐述：**

![类关系图](C:\Users\60007879\Pictures\Saved Pictures\类关系图.jpg)

- 各层级之间类的关系应该遵循：具体依赖于抽象，抽象不依赖具体，设计接口的目的就是达成约定与规范，通常情况下接口在定义完成后不轻易改变，所以层级之间依赖于接口，降低耦合，避免了系统出现牵一发而动全身的情况。
- 对于基础设施中持久化接口与外部服务接口，接口定义在领域层，在基础设施层进行实现（借鉴SPI设计），这样处理领域层没有多余的依赖，只关系核心业务逻辑处理，可通过Mock方式实现单元测试，进一步降低了系统耦合度与复杂度。

**防腐层（ACl）：**

​	这种常见的设计模式叫做Anti-Corruption Layer（防腐层或ACL）。很多时候我们的系统会去依赖其他的系统，而被依赖的系统可能包含不合理的数据结构、API、协议或技术实现，如果对外部系统强依赖，会导致我们的系统被”腐蚀“。这个时候，通过在系统间加入一个防腐层，能够有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。

无防腐层的情况：

​	![preview](https://pic2.zhimg.com/v2-c8c1950272b46a499d196e02333b7339_r.jpg)

有防腐层的情况：

![preview](https://pic3.zhimg.com/v2-251ec60197da62a65d1613a4d20767be_r.jpg)

ACL 不仅仅只是多了一层调用，在实际开发中ACL能够提供更多强大的功能：

- 适配器：很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。比如我们通过封装PayUser和Money对象，转化了外部接口如：Member、Channel的入参和出参，让入参出参更符合我们系统的标准。
- 缓存：对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。
- 兜底：如果外部依赖的稳定性较差，一个能够有效提升我们系统稳定性的策略是通过ACL起到兜底的作用，比如当外部依赖出问题后，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑一般都比较复杂，如果散落在核心业务代码中会很难维护，通过集中在ACL中，更加容易被测试和修改。
- 易于测试：类似于之前的Repository，ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。
- 功能开关：有些时候我们希望能在某些场景下开放或关闭某个接口的功能，或者让某个接口返回一个特定的值，我们可以在ACL配置功能开关来实现，而不会对真实业务代码造成影响。